> This is a person written summary on the discussion we had as a milestone 2 project planning (1/20/2026). Recording of this meeting can be found [here](</pm/pm-2025/2026_01_14/Senior project room>)

This discussion was brought up because of several problems that we faced while working on operator. First, the manually implemented serial and deserialization logic which opened us to potentially having an incorrect implementation of the request handling. Second, the current socket protocol is not very suited for our request response API architecture. Third, operator is falling behind and could be massively improved upon with more helpers. However, gRPC is not a simple tool that we can just import utilities and compile. It requires a whole level of re-architecture that we aren't against having but requires that much more effort to implement. Therefore we had a whole team discussion on whether this is a good feature we want to have or not. Ultimately, we came to the conclusion that gRPC is a nice to have and going to be deprioritized over other features that is more urgent like getting driver code functional. The following are the reasons and how we have came to that conclusion.

First, we wanted to separate the feature set of gRPC into Protobuf feature set and RPC feature set. The Protobuf allows us to serialize and deserialize requests safely and predictably. Which we want to have because it give us a safe implementation of handling requests that is more predictable between languages like cpp used in operator and python used in commander. This is good to have and could be needed in some sense, but also wasn't needed as it was more of a future proofing where the project onboarded more inexperienced programmers.

However, this feature discussion wasn't just on the topic of Protobuf, it is on the topic of gRPC which adds the features of RPC to Protobuf features. Where the RPC allows us to have the freedom to architect our api interface to how ever we like supporting functionality like concurrent requests and asynchronous commands. There are probably also some nice syntax and performance benefits, but the main pros that comes with gRPC is just the fact that we have the ability to handle concurrency requests for performance benefits which means this isn't a necessity but much rather a future proofing that we do not know if this project is ever going to need. Especially without our performance metrics features, this is not something we can just assumed to have or need.

The last point we discussed was that we have other functional features that we wanted to get done before this non-functional feature. For example, bluey(ER-4) was no where close to being operable. The operator is also falling behind, but the feature of gRPC would not be putting operator up to where the commander is; the commander currently is looking to implement metrics counter and final touches on quality of life features. The gRPC implementation has been discussed as a feature that would act as a refactoring work and replacing the current implementation that is not really going to progress operator forward. 

This whole discussion lacked the analysis on the con of gRPC implementation and very light discussion around the technical details, but regardless we came to the conclusion that the trajectory of the project would heavily diverge for gRPC implementation and that was the fundamental factor that placed us on this path of de-prioritization of this feature. We still like the idea of gRPC and its benefits. We would love to continue implementation of gRPC, but we will halt development until necessary features are complete. 